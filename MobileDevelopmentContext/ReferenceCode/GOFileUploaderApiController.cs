////////////////////////////////////////////////////////////////////////////////////////////
// This is Generated Code
// You should not modify this code as it may be overwritten. Use Partial classes instead
// Generated By Generative Objects  
////////////////////////////////////////////////////////////////////////////////////////////
using System;
using System.IO;
using System.Text;
using Newtonsoft.Json;
using forkuapp.Data.DataObjects;
using forkuapp.BusinessLayer.Components.Server;
using GenerativeObjects.Practices.Logging;
using System.Collections.Generic;
using System.Linq;
using GenerativeObjects.Practices.Settings;
using GenerativeObjects.Practices.ExceptionHandling;
using GenerativeObjects.Practices.LayerSupportClasses.ServiceLayer;
using GenerativeObjects.Practices.LayerSupportClasses.ServiceLayer.Extensions;
using GenerativeObjects.Practices.LayerSupportClasses.DataLayer;
using GenerativeObjects.Practices.LayerSupportClasses.Features.Storage.Common;

using GenerativeObjects.Practices.ORMSupportClasses;
using Microsoft.AspNetCore.Http;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Options;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Configuration;


namespace forkuapp.ServiceLayer.ComponentApiControllers
{
    [ApiController]    
    public class GOFileUploaderApiController : GOControllerBase
    {
		private readonly IHttpContextAccessor _httpContextAccessor;
        private readonly IConfiguration _configuration;
        private IStorageProvider _storageProvider => _serviceProvider.GetServices<IStorageProvider>().Where(s => s.GetType().Name == _settingsProvider["StorageProvider"].ToString()).Single();

        public GOFileUploaderApiController(IServiceProvider serviceProvider, IConfiguration configuration, ISettingsProvider settingsProvider, ILogEngine logEngine, IHttpContextAccessor httpContextAccessor) : base (serviceProvider, settingsProvider, logEngine)
        {
            _configuration = configuration;
            _httpContextAccessor = httpContextAccessor;
        }

        private string __directoryToSaveDocs;

        private string _directoryToSaveDocs
        {
            get
            {
                if (String.IsNullOrEmpty(__directoryToSaveDocs))
                {
			        var webHostEnvironment = (IWebHostEnvironment) _httpContextAccessor.HttpContext.RequestServices.GetRequiredService(typeof(IWebHostEnvironment));

                    __directoryToSaveDocs = !String.IsNullOrEmpty(_configuration["StorageContainerFilePath"]) ? _configuration["StorageContainerFilePath"] : System.IO.Path.Combine(webHostEnvironment.WebRootPath, "/files/");
                }

                return __directoryToSaveDocs;
            }
        }

        [HttpPost]
		[Route("api/gofileuploader/uploadfile")]
        public async Task<ActionResult<UploadFileInfo>> UploadFile()
        {
            Exception error = null;

            try
            {
                // Notify 'request begins' to extensions
                Extensions.OnRequestAction(new ApiExtensionResponseData { action = "GET", context = "BEGIN", data = null });
				
		        var ufi = new UploadFileInfo();
    	        ufi.InternalName = Guid.NewGuid().ToString();
		        var file_path = "";

			              // Ensure the folder exists
     	        if(!Directory.Exists(_directoryToSaveDocs))
                {
                    Directory.CreateDirectory(_directoryToSaveDocs);
                }
 
				
                ufi.FileSize = _httpContextAccessor.HttpContext.Request.ContentLength??0;
                file_path = _directoryToSaveDocs.TrimEnd('\\').TrimEnd('/') + "\\" + ufi.InternalName;
		        // type will be defined during the SaveFile.
                
                var result = await SaveFileAsync(_httpContextAccessor.HttpContext, ufi, file_path);
                
                // Notify method call to extensions
		        Extensions.OnRequestAction(new ApiExtensionResponseData { action = "UploadFile", context = "BEFORE_CALL", data = null });

                return result;                            

            }
            catch (GOServerException exception)
            {
                error = exception;

                // Notify to extensions and re-throw
                Extensions.OnRequestAction(new ApiExtensionResponseData { action = "EXCEPTION", context = exception.GetType().Name, data = exception.ToString(), error = true });
                
                return Problem(exception.Message, exception.Reason);
            }
            catch (Exception exception)
            {
                error = exception;
 
                // Notify to extensions and re-throw
                Extensions.OnRequestAction(new ApiExtensionResponseData { action = "EXCEPTION", context = exception.GetType().Name, data = exception.ToString(), error = true });
                
                return Problem(exception.Message);
            }
            finally
            {
                // Check no transaction left running
                await _serviceProvider.GetRequiredService<IDataProviderTransaction>().AbortAnyOngoingTransactionAsync(error);
            }

		}

        public class UploadFileInfo
        {
            public string InternalName { get; set; }
            public string ClientName { get; set; }
            public long FileSize { get; set; }
            public string Type { get; set; }
        }
        
        private static Int32 IndexOf(Byte[] buffer, Int32 len, Byte[] boundaryBytes)
        {
            for (Int32 i = 0; i <= len - boundaryBytes.Length; i++)
            {
                Boolean match = true;
                for (Int32 j = 0; j < boundaryBytes.Length && match; j++)
                {
                    match = buffer[i + j] == boundaryBytes[j];
                }

                if (match)
                {
                    return i;
                }
            }

            return -1;
        }

		private async Task<UploadFileInfo> SaveFileAsync(HttpContext context, UploadFileInfo ufi, string file_path)
        {
	        using (StreamReader reader = new StreamReader(context.Request.Body))
            {
                var boundary = "--" + context.Request.ContentType.Split(';')[1].Split('=')[1];
                Byte[] boundaryBytes = Encoding.UTF8.GetBytes(boundary);
                var boundaryLen = boundaryBytes.Length;
                Byte[] buffer = new Byte[1024];
                Int32 len = await context.Request.Body.ReadAsync(buffer, 0, 1024);
                Int32 startPos = -1;
				// Find start boundary
                while (true)
                {
                    if (len == 0)
                    {
                        throw new Exception("Start Boundaray Not Found");
                    }

                    startPos = IndexOf(buffer, len, boundaryBytes);
                    if (startPos >= 0)
                    {
                        break;
                    }
                    else
                    {
                        Array.Copy(buffer, len - boundaryLen, buffer, 0, boundaryLen);
                        len = await context.Request.Body.ReadAsync(buffer, boundaryLen, 1024 - boundaryLen);
                    }
                }

                // Skip four lines (Boundary, Content-Disposition, Content-Type, and a blank)
                for (Int32 i = 0; i < 4; i++)
                {
                    while (true)
                    {
                        if (len == 0)
                        {
                            throw new Exception("Preamble not Found.");
                        }

                        startPos = Array.IndexOf(buffer, Encoding.UTF8.GetBytes("\n")[0], startPos);
                        if (startPos >= 0)
                        {
                            startPos++;
							if (i == 0) // Content-Disposition: ...; name=...;  filename="\"...\"
                            {
                                var dest = new Byte[Array.IndexOf(buffer, Encoding.UTF8.GetBytes("\r")[0], startPos) - startPos];
                                Array.Copy(buffer, startPos, dest, 0, Array.IndexOf(buffer, Encoding.UTF8.GetBytes("\r")[0], startPos) - startPos);
                                var filename = System.Text.Encoding.UTF8.GetString(dest).Split(';')[2].Trim(); // Get the filename parameter
                                filename = filename.Split('=')[1].Trim('\"'); // remove unused "
                                ufi.ClientName = filename;
								ufi.Type = Path.GetExtension(filename); // get the extension of the file.
								// Verify Type here ?

                                file_path = String.Concat(file_path, ufi.Type);
                            }
							break;

                        }
                        else
                        {
                            len = await context.Request.Body.ReadAsync(buffer, 0, 1024);
                        }
                    }
                }

				 // Default GO defined storage container is "files", which is used if we don't find a "StorageContainer" override in web.config

                string storageContainerName = String.IsNullOrEmpty(_configuration["StorageContainer"]) ? "files" : _configuration["StorageContainer"];
                string fsPath = String.Format("{0}/{1}/{2}{3}", _serviceProvider.GetRequiredService<IServicePath>().ProjectBaseURL(), storageContainerName, ufi.InternalName, ufi.Type);

				using (var fs = _storageProvider.GetFileStream(fsPath, FileMode.Create).Result)
	            {
                    Array.Copy(buffer, startPos, buffer, 0, len - startPos);
                    len = len - startPos;

                    while (true)
                    {
                        Int32 endPos = IndexOf(buffer, len, boundaryBytes);
                        if (endPos >= 0)
                        {
							// -2 is to take into account the newline before end boundary (\r\n, 2 chars)
                            if (endPos-2 > 0)
                            {
                                fs.Write(buffer, 0, endPos-2);
                            }
                            break;
                        }
                        else if (len <= boundaryLen)
                        {
                            throw new Exception("End Boundaray Not Found");
                        }
                        else
						{
                            fs.Write(buffer, 0, len - boundaryLen);
                            Array.Copy(buffer, len - boundaryLen, buffer, 0, boundaryLen);
                            len = await context.Request.Body.ReadAsync(buffer, boundaryLen, 1024 - boundaryLen) + boundaryLen;
                        }
                    }

					fs.Close();
                }

				ufi.InternalName = String.Concat(ufi.InternalName, ufi.Type);

				return ufi;
            }
        }
    }
}